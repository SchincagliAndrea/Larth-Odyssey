 spry        = $c300
 irqy            = $c350
 counter     = $c380

                    * = $C000                   

setup               ldx #0
                    lda #01
                    clc
loopyq              sta irqy,x  ; setup raster irq and sprite y lines 
                    adc #2
                    sta spry,x
                    clc
                    adc #22
                    inx
                    cpx #10
                    bne loopyq
                    lda #$fa
                    sta irqy,x
                    adc #2
                    sta spry,x                      
                    ; setup sprites as squares and pointers as per usual lol
                    lda #13
                    sta $07f8    ; data ptr spr1
                    sta $07f9    ; data ptr spr2
                    sta $07fa  ; data ptr spr3  
                    sta $07fb    ; data ptr spr4    
                    sta $07fc   ; data ptr spr5 
                    sta $07fd   ; data ptr spr6 
                    sta $07fe   ; data ptr spr7
                    sta $07ff   ; data ptr spr8

                    lda #$ff
                    ldx #$00
                    stx counter

loop                sta 832,x
                    inx
                    cpx #64
                    bne loop

                    ; setup sprite colours

                    lda #09
                    sta $D027 ; colour sp1
                    lda #01
                    sta $D028 ; colour sp2
                    lda #02
                    sta $D029 ; colour sp3
                    lda #03
                    sta $D02a ; colour sp4
                    lda #04
                    sta $D02b ; colour sp5
                    lda #05
                    sta $D02c ; colour sp6
                    lda #06
                    sta $D02d ; colour sp7
                    lda #07
                    sta $D02e ; colour sp8


                    ; set sprite x locations

                    ldx #0
                    lda #30
storex          sta $d000,x
                    clc
                    adc #25
                    inx
                    inx
                    cpx #16
                    bne storex

                    ; set sprite y locations

                    ldx #0
                    lda #03
storey          sta $d001,x
                    inx
                    inx
                    cpx #16
                    bne storey

                    lda #255
                    sta $D015 ; enable all sprites 

begin           sei        ;disable maskable IRQs

                    lda #$7f
                    sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips
                    sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
                                       ;stop it.

                    lda $dc0d   ;by reading this two registers we negate any pending CIA irqs.
                    lda $dd0d       ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
                                        ;we don't want that to happen.

                    lda #$01    ;this is how to tell the VICII to generate a raster interrupt
                    sta $d01a

                    lda #$01    ;this is how to tell at which rasterline we want the irq to be triggered
                    sta $d012

                    lda #00
                    sta $d021

                    lda #29         ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
                    sta $d011   ;the 9th bit for the rasterline we want our irq to be triggered.
                                        ;here we simply set up a character screen, leaving the topmost bit 0.

                    lda #$35    ;we turn off the BASIC and KERNAL rom here
                    sta $01         ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
                                        ;SID/VICII/etc are visible

                    lda #<irq1  ;this is how we set up
                    sta $fffe       ;the address of our interrupt code
                    lda #>irq1
                    sta $ffff

                    cli                 ;enable maskable interrupts again

redo                jmp redo            ;we better don't RTS, the ROMS are now switched off, there's no way back to the system


                * = $c200
irq1

            ;Being all kernal irq handlers switched off we have to do more work by ourselves.
            ;When an interrupt happens the CPU will stop what its doing, store the status and return address
            ;into the stack, and then jump to the interrupt routine. It will not store other registers, and if
            ;we destroy the value of A/X/Y in the interrupt routine, then when returning from the interrupt to
            ;what the CPU was doing will lead to unpredictable results (most probably a crash). So we better
            ;store those registers, and restore their original value before reentering the code the CPU was
            ;interrupted running.

            ;If you won't change the value of a register you are safe to not to store / restore its value.
            ;However, it's easy to screw up code like that with later modifying it to use another register too
            ;and forgetting about storing its state.

            ;The method shown here to store the registers is the most orthodox and most failsafe.

                    pha        ;store register A in stack
                    txa
                    pha        ;store register X in stack
                    tya
                    pha        ;store register Y in stack

                    php

                    lda #$ff        ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.
                    sta $d019   ;if you don't do this the interrupt condition will be present all the time and you end
                                       ;up having the CPU running the interrupt code all the time, as when it exists the
                                       ;interrupt, the interrupt request from the VICII will be there again regardless of the
                                       ;rasterline counter.

                                       ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they
                                       ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.

                    ldx counter
                    lda $d012
                    cmp #$01
                    beq opentop
                    cmp #$fa
                    beq openbase

setpos          lda spry,x

                    sta $d001
                    sta $d003
                    sta $d005
                    sta $d007
                    sta $d009
                    sta $d00b
                    sta $d00d
                    sta $d00f
                    jmp setirq

opentop     lda #29
                    sta $d011
                    jmp setirq

openbase        lda #21
                    sta $d011

setirq          inx
                    cpx #12
                    bne nextirq
                    ldx #0
nextirq         stx counter
                    lda irqy, x
                    sta $d012

finish          plp         
                    pla
                    tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)
                    pla
                    tax        ;restore register X from stack
                    pla        ;restore register A from stack

                    rti        ;Return From Interrupt, this will load into the Program Counter register the address
                               ;where the CPU was when the interrupt condition arised which will make the CPU continue
                               ;the code it was interrupted at also restores the status register of the CPU